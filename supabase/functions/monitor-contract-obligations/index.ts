// supabase/functions/monitor-contract-obligations/index.ts// Mission 1: Edge Function pour le monitoring des obligations contractuellesimport { serve } from "https://deno.land/std@0.168.0/http/server.ts";import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';const corsHeaders = {  'Access-Control-Allow-Origin': '*',  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',};interface MonitoringOptions {  contract_id?: string;  monitoring_type?: 'deadlines' | 'renewals' | 'payments' | 'all';  days_ahead?: number;}serve(async (req) => {  // Handle CORS preflight requests  if (req.method === 'OPTIONS') {    return new Response('ok', { headers: corsHeaders });  }  try {    // Initialize Supabase client    const supabaseClient = createClient(      Deno.env.get('SUPABASE_URL') ?? '',      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',    );    const options: MonitoringOptions = await req.json();    const { contract_id, monitoring_type = 'all', days_ahead = 30 } = options;    console.log('Monitoring des contrats:', { contract_id, monitoring_type, days_ahead });    // 1. Récupérer les contrats à monitorer    let contractsQuery = supabaseClient      .from('contracts')      .select(`        id,        contract_number,        title,        status,        start_date,        end_date,        renewal_date,        auto_renewal,        companies:client_id (          id, name, email        )      `)      .in('status', ['signed', 'pending_client', 'review']);    if (contract_id) {      contractsQuery = contractsQuery.eq('id', contract_id);    }    const { data: contracts, error: contractsError } = await contractsQuery;    if (contractsError) {      throw new Error(`Erreur récupération contrats: ${contractsError.message}`);    }    const alerts = [];    const now = new Date();    const alertThreshold = new Date(now.getTime() + days_ahead * 24 * 60 * 60 * 1000);    // 2. Analyser chaque contrat    for (const contract of contracts || []) {      const endDate = new Date(contract.end_date);      const renewalDate = contract.renewal_date ? new Date(contract.renewal_date) : null;      // Vérifier les expirations      if (monitoring_type === 'all' || monitoring_type === 'deadlines') {        if (endDate < now) {          alerts.push({            contract_id: contract.id,            alert_type: 'contract_expired',            severity: 'critical',            message: `Le contrat ${contract.contract_number} a expiré`,            due_date: endDate,            details: {              contract_number: contract.contract_number,              client_name: contract.companies?.name,              expired_days: Math.floor((now.getTime() - endDate.getTime()) / (24 * 60 * 60 * 1000))            }          });        } else if (endDate <= alertThreshold) {          const daysUntilExpiry = Math.floor((endDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000));          alerts.push({            contract_id: contract.id,            alert_type: daysUntilExpiry <= 7 ? 'contract_expiring' : 'contract_expiring_soon',            severity: daysUntilExpiry <= 7 ? 'high' : 'medium',            message: `Le contrat ${contract.contract_number} expire dans ${daysUntilExpiry} jours`,            due_date: endDate,            details: {              contract_number: contract.contract_number,              client_name: contract.companies?.name,              days_remaining: daysUntilExpiry            }          });        }      }      // Vérifier les renouvellements      if (monitoring_type === 'all' || monitoring_type === 'renewals') {        if (renewalDate) {          if (renewalDate < now) {            alerts.push({              contract_id: contract.id,              alert_type: 'renewal_overdue',              severity: 'high',              message: `Le renouvellement du contrat ${contract.contract_number} est en retard`,              due_date: renewalDate,              details: {                contract_number: contract.contract_number,                client_name: contract.companies?.name,                overdue_days: Math.floor((now.getTime() - renewalDate.getTime()) / (24 * 60 * 60 * 1000))              }            });          } else if (renewalDate <= alertThreshold) {            const daysUntilRenewal = Math.floor((renewalDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000));            alerts.push({              contract_id: contract.id,              alert_type: 'renewal_due_soon',              severity: 'medium',              message: `Le renouvellement du contrat ${contract.contract_number} est dû dans ${daysUntilRenewal} jours`,              due_date: renewalDate,              details: {                contract_number: contract.contract_number,                client_name: contract.companies?.name,                days_until_renewal: daysUntilRenewal              }            });          }        } else if (contract.auto_renewal && endDate <= alertThreshold) {          // Auto-renouvellement à prévoir          const daysUntilRenewal = Math.floor((endDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000));          if (daysUntilRenewal <= 30) {            alerts.push({              contract_id: contract.id,              alert_type: 'renewal_due_soon',              severity: 'low',              message: `Auto-renouvellement du contrat ${contract.contract_number} prévu dans ${daysUntilRenewal} jours`,              due_date: endDate,              details: {                contract_number: contract.contract_number,                client_name: contract.companies?.name,                auto_renewal: true,                days_until_renewal: daysUntilRenewal              }            });          }        }      }      // Vérifier le score de conformité      const { data: contractDetail } = await supabaseClient        .from('contracts')        .select('compliance_score')        .eq('id', contract.id)        .single();      if (contractDetail?.compliance_score && contractDetail.compliance_score < 70) {        alerts.push({          contract_id: contract.id,          alert_type: 'low_compliance_score',          severity: contractDetail.compliance_score < 50 ? 'high' : 'medium',          message: `Score de conformité faible pour le contrat ${contract.contract_number}`,          details: {            contract_number: contract.contract_number,            client_name: contract.companies?.name,            compliance_score: contractDetail.compliance_score          }        });      }    }    // 3. Sauvegarder les nouvelles alertes    for (const alert of alerts) {      // Vérifier si l'alerte existe déjà      const { data: existingAlert } = await supabaseClient        .from('contract_alerts')        .select('id')        .eq('contract_id', alert.contract_id)        .eq('alert_type', alert.alert_type)        .eq('status', 'active')        .single();      if (!existingAlert) {        await supabaseClient          .from('contract_alerts')          .insert({            ...alert,            status: 'active',            created_at: new Date().toISOString(),            updated_at: new Date().toISOString()          });      }    }    // 4. Préparer le résumé    const summary = {      total_contracts: contracts?.length || 0,      active_alerts: alerts.length,      critical_alerts: alerts.filter(a => a.severity === 'critical').length,      high_alerts: alerts.filter(a => a.severity === 'high').length,      alerts_by_type: {        expiring: alerts.filter(a => a.alert_type.includes('expiring')).length,        renewals: alerts.filter(a => a.alert_type.includes('renewal')).length,        compliance: alerts.filter(a => a.alert_type === 'low_compliance_score').length      }    };    console.log('Monitoring terminé:', summary);    return new Response(      JSON.stringify({        success: true,        alerts,        summary,        contracts_monitored: contracts?.length || 0      }),      {        headers: { ...corsHeaders, 'Content-Type': 'application/json' },        status: 200,      }    );  } catch (error) {    console.error('Erreur monitoring:', error);    return new Response(      JSON.stringify({        success: false,        error: error.message      }),      {        headers: { ...corsHeaders, 'Content-Type': 'application/json' },        status: 500,      }    );  }});